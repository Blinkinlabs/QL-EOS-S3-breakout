{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"QL-EOS-S3-breakout A breadboard-friendly, low part count breakout board for the QuickLogic EOS-S3 ARM/FPGA IC. The goals of this project are: Low-cost, minimum viable ARM+FPGA design that is breadboard compatable Footprint, power, UART pin compatibility with Teensy 3.2. All pins on Bank A placed in a group, because they can have their IO voltage set with a reference Bootstrap, SPI flash, and reset pins placed in non-breadboardable location to avoid inadvertant interference with application circuit Pins with multiple IO functions preferred over FPGA only pins Pins in understandable (ascending) order by FPGA IO number, when possible See the release PDF for the schematic. Want one? Sign up to be notified when they are available!","title":"QL-EOS-S3-breakout"},{"location":"#ql-eos-s3-breakout","text":"A breadboard-friendly, low part count breakout board for the QuickLogic EOS-S3 ARM/FPGA IC. The goals of this project are: Low-cost, minimum viable ARM+FPGA design that is breadboard compatable Footprint, power, UART pin compatibility with Teensy 3.2. All pins on Bank A placed in a group, because they can have their IO voltage set with a reference Bootstrap, SPI flash, and reset pins placed in non-breadboardable location to avoid inadvertant interference with application circuit Pins with multiple IO functions preferred over FPGA only pins Pins in understandable (ascending) order by FPGA IO number, when possible See the release PDF for the schematic. Want one? Sign up to be notified when they are available!","title":"QL-EOS-S3-breakout"},{"location":"advanced/","text":"Advanced topics Reprogramming the SPI flash Introduction The EOS-S3 SoC does not have internal nonvolatile memory, so it boots from an external SPI flash. The breakout board has a bootloader pre-installed in the flash memory, which can be used to program the device using it's USB port. However, if the bootloader becomes corrupted for whatever reason, it can be useful to restore the whole SPI flash. To do this, you'll need a Teensy with the spiflash firmware loaded. First, some technical details. This is the flash memory layout that the quickfeather bootloader is expecting: Item Status Start Size End Start Size End bootloader Used 0x0000_0000 0x0001_0000 0x0000_FFFF 0 65,536 65,536 bootfpga CRC Used 0x0001_0000 8 0x0001_0007 65,536 8 65,544 appfpga CRC Future 0x0001_1000 8 0x0001_1007 69,632 8 69,640 appffe CRC Future 0x0001_2000 8 0x0001_2007 73,728 8 73,736 M4app CRC Used 0x0001_3000 8 0x0001_3007 77,824 8 77,832 bootloader CRC Used 0x0001_4000 8 0x0001_4007 81,920 8 81,928 bootfpga Used 0x0002_0000 0x0002_0000 0x0003_FFFF 131,072 131,072 262,144 appfpga Future 0x0004_0000 0x0002_0000 0x0005_FFFF 262,144 131,072 393,216 appffe Future 0x0006_0000 0x0002_0000 0x0007_FFFF 393,216 131,072 524,288 M4app Used 0x0008_0000 0x0006_E000 0x000E_DFFF 524,288 450,560 974,848 The hardware in the SoC only cares about the first section, which contains the bootloader. When it comes out of reset, configuration logic in the SoC reads 32 bits of data from the SPI flash location 0x120, which contains a device ID, the size of the bootloader image, and the desired SPI clock setting. If these are valid, the configuration logic then copies the bootloader into the device SRAM, and then starts the ARM processor. Once it starts, the bootloader displays a prompt on the UART pins, then waits 5 seconds. If the user button is pressed during these 5 seconds, then it loads the bootfpga image into the FPGA, which allows the user to reprogram the device using the TinyFPGA programmer. If the button is not pressed within 5 seconds, the bootloader attempts to load the user program from the SPI flash into SRAM. It then verifies that the CRC makes (TODO: Does it actually do this?), and if it does, reconfigures the ARM to point to that code, to enter the user program. The TLDR here is that if we want to write a raw image to the flash, we'll need at least the bootloader, bootloader CRC, bootfpga, andd bootfpga CRC sections to be present. For extra points, we can also preinstall a user app by filling the M4app and M4app CRC sections. Step 1: Build the bootloader First, let's build the bootloader: cd ~/ql-eos-s3/qorc-sdk/bl_apps/bl_bootloader/GCC_Project make TODO: what sets up the 0x120 offset in the bootloader binary? Step 2: Make a flash image A tool to build a suitable image is included in the bl apps . Using it with the default options will grab the bootloader binary image that we just compiled above, as well as a (for now) precompiled appfpga image: cd ~/ql-eos-s3/qorc-sdk/bl_apps/tools python3 build_flash_image.py added section:bootloader at:0x00000000 size:38228 crc:0x555d0a3e added section:bootfpga at:0x00020000 size:75960 crc:0x82fc1983 Wrote 0xee000 bytes to image.bin This should create a file called 'image.bin', which we can then load on the SPI flash chip, starting at offset 0. Step 3: Flash it Connect the Teensy to the dev board like so. Be sure to short the 'RST' pin on the board to 'GND', to prevent the SoC from booting: TODO: text version of the pin table Next, connect both the Teensy and the board to your computer using USB. Use your favorite serial terminal to connect to the Teensy. Issue the 'i' command to check if the SPI flash can be identified: i C84015C8 Note: The device ID for the flash on your board may differ, this is for the 2MB version Now, tell the Teensy that we want to write EE000 bytes to the SPI flash, starting at offset 0. If the flash image was a different length, use that instead: u0 EE0000 G 00000000 EE0000 Note: The 'u' will not be echoed to the terminal Exit the serial terminal, and then use the PV command to write the image: pv image.bin > /dev/ttyACM0 Now, detach the Teensy, then remove the jumper between RST and GND to boot flash image. Set the IO pins in Bank A to a different reference voltage Introduction If you need to interface with a device that uses a different logic voltage than 3.3V, it is possible to set the reference voltage for the pins on Bank A. Step 1: Cut the VCCIOA trace on the back of the board On the back side of the board, cut the short copper trace in the middle of the 'VCCIOA' pad. This will disconnect the VCCIOA power line from the on-board 3.3V regulator: Step 2: Provide a 1.71 - 3.6V reference on the VCCA pin Once the trace has been cut, you'll need to connect an external voltage to the header pin marked 'VCCA'. Then, all of the pins on the right-hand side of the board will be referenced to the external supply: Note: The datasheet specifies a range of 1.71-3.6V for safe operation Attach a JTAG debugger TODO Using JTAG with the RevB board reuqires pulling up both IO_8 and IO_9, and supplying a clock to FCLK. Additionally, the 10k pullups on SWD and SCK may not be present, and would need to be added externally. A future revision will use an alternate JTAG pin mapping, to allow it to be used with the on-board oscillator.","title":"Advanced Topics"},{"location":"advanced/#advanced-topics","text":"","title":"Advanced topics"},{"location":"advanced/#reprogramming-the-spi-flash","text":"","title":"Reprogramming the SPI flash"},{"location":"advanced/#introduction","text":"The EOS-S3 SoC does not have internal nonvolatile memory, so it boots from an external SPI flash. The breakout board has a bootloader pre-installed in the flash memory, which can be used to program the device using it's USB port. However, if the bootloader becomes corrupted for whatever reason, it can be useful to restore the whole SPI flash. To do this, you'll need a Teensy with the spiflash firmware loaded. First, some technical details. This is the flash memory layout that the quickfeather bootloader is expecting: Item Status Start Size End Start Size End bootloader Used 0x0000_0000 0x0001_0000 0x0000_FFFF 0 65,536 65,536 bootfpga CRC Used 0x0001_0000 8 0x0001_0007 65,536 8 65,544 appfpga CRC Future 0x0001_1000 8 0x0001_1007 69,632 8 69,640 appffe CRC Future 0x0001_2000 8 0x0001_2007 73,728 8 73,736 M4app CRC Used 0x0001_3000 8 0x0001_3007 77,824 8 77,832 bootloader CRC Used 0x0001_4000 8 0x0001_4007 81,920 8 81,928 bootfpga Used 0x0002_0000 0x0002_0000 0x0003_FFFF 131,072 131,072 262,144 appfpga Future 0x0004_0000 0x0002_0000 0x0005_FFFF 262,144 131,072 393,216 appffe Future 0x0006_0000 0x0002_0000 0x0007_FFFF 393,216 131,072 524,288 M4app Used 0x0008_0000 0x0006_E000 0x000E_DFFF 524,288 450,560 974,848 The hardware in the SoC only cares about the first section, which contains the bootloader. When it comes out of reset, configuration logic in the SoC reads 32 bits of data from the SPI flash location 0x120, which contains a device ID, the size of the bootloader image, and the desired SPI clock setting. If these are valid, the configuration logic then copies the bootloader into the device SRAM, and then starts the ARM processor. Once it starts, the bootloader displays a prompt on the UART pins, then waits 5 seconds. If the user button is pressed during these 5 seconds, then it loads the bootfpga image into the FPGA, which allows the user to reprogram the device using the TinyFPGA programmer. If the button is not pressed within 5 seconds, the bootloader attempts to load the user program from the SPI flash into SRAM. It then verifies that the CRC makes (TODO: Does it actually do this?), and if it does, reconfigures the ARM to point to that code, to enter the user program. The TLDR here is that if we want to write a raw image to the flash, we'll need at least the bootloader, bootloader CRC, bootfpga, andd bootfpga CRC sections to be present. For extra points, we can also preinstall a user app by filling the M4app and M4app CRC sections.","title":"Introduction"},{"location":"advanced/#step-1-build-the-bootloader","text":"First, let's build the bootloader: cd ~/ql-eos-s3/qorc-sdk/bl_apps/bl_bootloader/GCC_Project make TODO: what sets up the 0x120 offset in the bootloader binary?","title":"Step 1: Build the bootloader"},{"location":"advanced/#step-2-make-a-flash-image","text":"A tool to build a suitable image is included in the bl apps . Using it with the default options will grab the bootloader binary image that we just compiled above, as well as a (for now) precompiled appfpga image: cd ~/ql-eos-s3/qorc-sdk/bl_apps/tools python3 build_flash_image.py added section:bootloader at:0x00000000 size:38228 crc:0x555d0a3e added section:bootfpga at:0x00020000 size:75960 crc:0x82fc1983 Wrote 0xee000 bytes to image.bin This should create a file called 'image.bin', which we can then load on the SPI flash chip, starting at offset 0.","title":"Step 2: Make a flash image"},{"location":"advanced/#step-3-flash-it","text":"Connect the Teensy to the dev board like so. Be sure to short the 'RST' pin on the board to 'GND', to prevent the SoC from booting: TODO: text version of the pin table Next, connect both the Teensy and the board to your computer using USB. Use your favorite serial terminal to connect to the Teensy. Issue the 'i' command to check if the SPI flash can be identified: i C84015C8 Note: The device ID for the flash on your board may differ, this is for the 2MB version Now, tell the Teensy that we want to write EE000 bytes to the SPI flash, starting at offset 0. If the flash image was a different length, use that instead: u0 EE0000 G 00000000 EE0000 Note: The 'u' will not be echoed to the terminal Exit the serial terminal, and then use the PV command to write the image: pv image.bin > /dev/ttyACM0 Now, detach the Teensy, then remove the jumper between RST and GND to boot flash image.","title":"Step 3: Flash it"},{"location":"advanced/#set-the-io-pins-in-bank-a-to-a-different-reference-voltage","text":"","title":"Set the IO pins in Bank A to a different reference voltage"},{"location":"advanced/#introduction_1","text":"If you need to interface with a device that uses a different logic voltage than 3.3V, it is possible to set the reference voltage for the pins on Bank A.","title":"Introduction"},{"location":"advanced/#step-1-cut-the-vccioa-trace-on-the-back-of-the-board","text":"On the back side of the board, cut the short copper trace in the middle of the 'VCCIOA' pad. This will disconnect the VCCIOA power line from the on-board 3.3V regulator:","title":"Step 1: Cut the VCCIOA trace on the back of the board"},{"location":"advanced/#step-2-provide-a-171-36v-reference-on-the-vcca-pin","text":"Once the trace has been cut, you'll need to connect an external voltage to the header pin marked 'VCCA'. Then, all of the pins on the right-hand side of the board will be referenced to the external supply: Note: The datasheet specifies a range of 1.71-3.6V for safe operation","title":"Step 2: Provide a 1.71 - 3.6V reference on the VCCA pin"},{"location":"advanced/#attach-a-jtag-debugger","text":"TODO Using JTAG with the RevB board reuqires pulling up both IO_8 and IO_9, and supplying a clock to FCLK. Additionally, the 10k pullups on SWD and SCK may not be present, and would need to be added externally. A future revision will use an alternate JTAG pin mapping, to allow it to be used with the on-board oscillator.","title":"Attach a JTAG debugger"},{"location":"getting_started/","text":"Get Started Introduction The QL-EOS-S3 board is a unique, low-cost microcontroller with a built-in FPGA. What you need Hardware: QL-EOS-S3 breakout board USB-C cable 3.3V FTDI cable (or other USB-serial converter) (optional) Teensy 3.2 , for restoring the SPI flash. (optional) ARM SWD adapter, such as the Black magic probe Software: ARM GCC toolchain, to compile code for the Cortex M4 processor Symbiflow toolchain, for generating FPGA bitstreams The QORC Software Development Kit Blinkinlabs example projects Installation Step 1: Install the toolchain Follow the toolchain setup instructions Step 2: Build an example project Test a project that uses both the ARM and FPGA toolchains: cd ~/ql-eos-s3/qorc-sdk/bl_apps/bl_helloworldhw/GCC_Project make Step 3: Connect to the board Connect your board to your computer using a USB cable. Next, connect an FTDI cable: Open your favorite serial terminal, and connect to the FTDI serial port with 115200,8N1 setting. Press the reset button on the board (the one closest to the SPI flash chip). The device should send a prompt: ########################## Blinkinlabs QL-EOS-S3 Breakout Bootloader SW Version: qorc-sdk/qf-apps/qf_bootloader(v2) (GCC) Nov 11 2020 00:29:45 ########################## As soon as you see the prompt, press and hold the user button (the one furthest from the SPI flash chip). The device will then go into bootloader mode, and send a prompt: User button pressed: switch to download mode FPGA Programmed Presss Reset button after flashing .. If instead you see a message 'User button not pressed: proceeding to load application', just press reset, and try again. Step 4: Upload the example project And try uploading it to the board: python3 ~/ql-eos-s3/TinyFPGA-Programmer-Application/tinyfpga-programmer-gui.py --m4app output/bin/bl_helloworldhw.bin --reset CLI mode ports = ['/dev/ttyACM0 (QuickFeather)'] 1 Using port /dev/ttyACM0 (QuickFeather) Programming m4 application with bl_helloworldhw.bin Erasing designated flash pages Erase 64.0 KiB ( 0xd8 ) at 0x80000 Erase 32.0 KiB ( 0x52 ) at 0x90000 Erase 4.0 KiB ( 0x20 ) at 0x98000 Writing binary Write 102172 bytes [XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX] Verifying binary FastREAD 0x0B ( 102172 ) [XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX] Success: read_back == data Writing metadata Erasing designated flash pages Erase 4.0 KiB ( 0x20 ) at 0x13000 Writing metadata Write 8 bytes [X] ] Verifying metadata FastREAD 0x0B ( 8 ) [X] ] Success: read_back == data Reset the device boot sent On the serial terminal, the board should send progress updates: Addr: 0x00080000 Erase 64 KBytes() .. done Addr: 0x00090000 Erase 32 KBytes() .. done Addr: 0x00098000 Erase 4 KBytes() .. done Addr: 0x00013000 Erase 4 KBytes() .. done And once it's finished, it will automatically restart: ########################## Blinkinlabs QL-EOS-S3 Breakout Bootloader SW Version: qorc-sdk/qf-apps/qf_bootloader(v2) (GCC) Nov 11 2020 00:29:45 ########################## User button not pressed: proceeding to load application ########################## Quicklogic QuickFeather Standalone FPGA SW Version: qorc-sdk/qf_apps/qf_helloworldhw Nov 18 2020 18:01:17 ##########################","title":"Getting Started"},{"location":"getting_started/#get-started","text":"","title":"Get Started"},{"location":"getting_started/#introduction","text":"The QL-EOS-S3 board is a unique, low-cost microcontroller with a built-in FPGA.","title":"Introduction"},{"location":"getting_started/#what-you-need","text":"Hardware: QL-EOS-S3 breakout board USB-C cable 3.3V FTDI cable (or other USB-serial converter) (optional) Teensy 3.2 , for restoring the SPI flash. (optional) ARM SWD adapter, such as the Black magic probe Software: ARM GCC toolchain, to compile code for the Cortex M4 processor Symbiflow toolchain, for generating FPGA bitstreams The QORC Software Development Kit Blinkinlabs example projects","title":"What you need"},{"location":"getting_started/#installation","text":"","title":"Installation"},{"location":"getting_started/#step-1-install-the-toolchain","text":"Follow the toolchain setup instructions","title":"Step 1: Install the toolchain"},{"location":"getting_started/#step-2-build-an-example-project","text":"Test a project that uses both the ARM and FPGA toolchains: cd ~/ql-eos-s3/qorc-sdk/bl_apps/bl_helloworldhw/GCC_Project make","title":"Step 2: Build an example project"},{"location":"getting_started/#step-3-connect-to-the-board","text":"Connect your board to your computer using a USB cable. Next, connect an FTDI cable: Open your favorite serial terminal, and connect to the FTDI serial port with 115200,8N1 setting. Press the reset button on the board (the one closest to the SPI flash chip). The device should send a prompt: ########################## Blinkinlabs QL-EOS-S3 Breakout Bootloader SW Version: qorc-sdk/qf-apps/qf_bootloader(v2) (GCC) Nov 11 2020 00:29:45 ########################## As soon as you see the prompt, press and hold the user button (the one furthest from the SPI flash chip). The device will then go into bootloader mode, and send a prompt: User button pressed: switch to download mode FPGA Programmed Presss Reset button after flashing .. If instead you see a message 'User button not pressed: proceeding to load application', just press reset, and try again.","title":"Step 3: Connect to the board"},{"location":"getting_started/#step-4-upload-the-example-project","text":"And try uploading it to the board: python3 ~/ql-eos-s3/TinyFPGA-Programmer-Application/tinyfpga-programmer-gui.py --m4app output/bin/bl_helloworldhw.bin --reset CLI mode ports = ['/dev/ttyACM0 (QuickFeather)'] 1 Using port /dev/ttyACM0 (QuickFeather) Programming m4 application with bl_helloworldhw.bin Erasing designated flash pages Erase 64.0 KiB ( 0xd8 ) at 0x80000 Erase 32.0 KiB ( 0x52 ) at 0x90000 Erase 4.0 KiB ( 0x20 ) at 0x98000 Writing binary Write 102172 bytes [XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX] Verifying binary FastREAD 0x0B ( 102172 ) [XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX] Success: read_back == data Writing metadata Erasing designated flash pages Erase 4.0 KiB ( 0x20 ) at 0x13000 Writing metadata Write 8 bytes [X] ] Verifying metadata FastREAD 0x0B ( 8 ) [X] ] Success: read_back == data Reset the device boot sent On the serial terminal, the board should send progress updates: Addr: 0x00080000 Erase 64 KBytes() .. done Addr: 0x00090000 Erase 32 KBytes() .. done Addr: 0x00098000 Erase 4 KBytes() .. done Addr: 0x00013000 Erase 4 KBytes() .. done And once it's finished, it will automatically restart: ########################## Blinkinlabs QL-EOS-S3 Breakout Bootloader SW Version: qorc-sdk/qf-apps/qf_bootloader(v2) (GCC) Nov 11 2020 00:29:45 ########################## User button not pressed: proceeding to load application ########################## Quicklogic QuickFeather Standalone FPGA SW Version: qorc-sdk/qf_apps/qf_helloworldhw Nov 18 2020 18:01:17 ##########################","title":"Step 4: Upload the example project"},{"location":"pinout/","text":"Pinout and Peripherals Pinout Compared to a normal microcontroller, the pins on the QL-EOS-S3 SoC are a little goofy. Similar to a normal microcontroller, it has some hardware GPIO pins that are attached to the ARM core, along with standard peripherals such as UART, and SPI busses, along with an analog port. Unlike a normal microcontroller, however, most of the pins are not connected to the ARM core at all! Instead, they are all connected to the FPGA core, and can be used by writing your own peripherals in Verilog. Here is a map of all of the fixed pins on the board: All of the pins on the right and left sides of the boards can be used freely. Note that the two JTAG pins (IO_44 and IO_45 on RevB) have on-board pullup resistors to the 3.3V line. The pins in the center section are also possible to use use, however they affect how the SoC boots. Use with caution: SPI pins The SPI pins (CLK, MOSI, MISO, and SS1) are attached to the on-board SPI flash. The CLK, MOSI, and MISO pins can be safely shared with other SPI devices, as long as they do not interfere with the boot process. Use with caution: Bootstrap pins IO_8, IO_9, IO_19, and IO_20 are avaiable as general-purpose IO, however they have 10k pull-down resistors connected to them, and their values have to be logic low at boot time for the microcontroller to turn on correctly. Hardware GPIO The arm core is able to control 8 of the pins (marked GPIO0..7 in the pinout diagram). Here are the steps to use them: Step 1: Check that the GPIO is assigned to the correct pin Each GPIO can be connected to one of two hardware pins. The pin selection is stored in IOMUX_IO_REG_SEL, at 0x40004D60. Here is a table of the available GPIO pin mappings, and the proper one for the breakout board: GPIO Default pin Alternate pin Breakout board pin Notes 0 IO_6 IO_24 IO_6 1 IO_9 IO_26 IO_9 Bootstrap pin 2 IO_11 IO_28 IO_28 Breakout board uses alternate pin 3 IO_14 IO_30 IO_14 4 IO_18 IO_31 IO_18 Connected to USER BUTTON 5 IO_21 IO_36 IO_21 6 IO_22 IO_38 IO_22 Connected to STATUS LED 7 IO_23 IO_45 IO_23 Only GPIO2 needs to be assigned to the alternate pin, so the following can be used to fully configure the GPIO pin assignments: machine.mem32[0x40004D60] = (1<<2) Step 2: Configure the pin for GPIO mode Now that we know the pin that the GPIO is assigned to, the next step is to configure it for GPIO mode, as either an input or output. To do this, write to the IOMUX_PADxx_CTRL register associated with the pad. The address is: 0x40004C00 + 4*(pad number) Example: Configure pin IO_18 as a GPIO input with pull-up enabled: machine.mem32[0x40004C00 + (18*4)] = (0x3<<0) | (0x0<<3) | (1<<8) | (1<<5) | (1<<11) | (0x1<<6) Example: Configure pin IO_22 as a GPIO output with 4mA drive strength: machine.mem32[0x40004C00 + (22*4)] = (0x3<<0) | (0x0<<3) | (1<<8) Step 3: Read (or write) to the GPIO To read from a gpio, use the register MISC_IO_INPUT at 0x40005100. For instance, to read the value of GPIO4 (user button): print((machine.mem32[0x40005100] >> 4) & 0x1) To write a GPIO value, us the register MISC_IO_OUTPUT at 0x40005104. For instance, to set GPIO6 (status led) high: machine.mem32[0x40005104] |= (1 << 6) Interrupts Each GPIO pin can be used as a level or edge sensitive interrupt. All GPIO pins share a single interrupt vector. TODO: Example for using interrupts Example GPIO library Here is a barebones GPIO library, written in Micropython: class GPIO: IOMUX_BASE = 0x40004C00 IOMUX_IO_REG_SEL = 0x40004D60 MISC_IO_INPUT = 0x40005100 MISC_IO_OUTPUT = 0x40005104 def __init__(self): # Configure GPIO pin selects for breakout board # Note: Only GPIO2 uses alternate pin setting machine.mem32[self.IOMUX_IO_REG_SEL] = (1<<2) def write(self, gpio, val): if val == 0: # Low machine.mem32[self.MISC_IO_OUTPUT] &= ~(1 << gpio) else: # High machine.mem32[self.MISC_IO_OUTPUT] |= (1 << gpio) def read(self, gpio): return ((machine.mem32[self.MISC_IO_INPUT] >> gpio) & 0x01) def pinmode(self, gpio, mode): pads = (6,9,11,14,18,21,22,23) if mode == 'input': machine.mem32[self.IOMUX_BASE + pads[gpio]*4] = (0x3<<0) | (0x0<<3) | (1<<8) | (1<<5) | (1<<11) elif mode == 'input_pullup': machine.mem32[self.IOMUX_BASE + pads[gpio]*4] = (0x3<<0) | (0x0<<3) | (1<<8) | (1<<5) | (1<<11) | (0x1<<6) elif mode == 'output': machine.mem32[self.IOMUX_BASE + pads[gpio]*4] = (0x3<<0) | (0x0<<3) | (1<<8) And to use it: gpio=GPIO() gpio.pinmode(6,'output') gpio.write(6,1) # turn on LED gpio.pinmode(4,'input_pullup') gpio.read(4) # read button input UART TODO SPI Master SPI Master 1 is connected to the ARM, and available for use. Unfortunately, the technical reference manual is very light on the details, and the SDK drivers are buggy and poorly documented. It appears to be an instantion of a Synopsys DesignWire IP 'DW_apb_ssi'. Because this a commonly used IP block, there are some references to similar hardware: Linux driver TODO Analog to digital controller TODO FPGA The FPGA is the swiss army knife of peripherals Clocks There are 3 input clocks from the ARM to the FPGA: Clock Name Max frequency Notes C16 Sys_Clk0 ? General purpose C21 Sys_Clk1 ? General purpose C02 Sys_Pclk ? SPI master APB bus clock (?) Sys_Clk0 and Sys_Clk1 are 'general purpose' clocks. Both are fed from dedicated clocks, so configuring them should not intefere with any other ARM peripherals. They can be driven by either the high or low speed system clocks, with a divisor from 0-512. The technical reference manual specifies a default maximum speed of 10MHz, however speeds up to the system clock (72MHz) appear to function well. Sys_Pclk is fed from C02, which is shared with some other ARM peripherals. It is also available for use, but reconfiguring it might cause problems. There are 2 output clocks from the FPGA to the ARM: Clock Name Max frequency Usage C40 WB_CLK 10 Mhz Fabric to Wishbone clock C41 Sys_Pkfb_Clk 10 MHz Fabric to PKFB (packet fifo) clock Both of these clocks are special purpose, and should be configured if you are planning to use their associated peripherals. IO pads The FPGA can control all of the IO pads, including a direction function. However, the pads must first be configured by the ARM processor, for both driving source and I/O control functions. Some of the pads are special clock inputs (TODO: which ones?) SPI Master The FPGA is supposed to be able to interface with the SPI master, for some reason. It's not clear how to do this, or what the intended use case is. Communicating with the FPGA To get the best use out of your FPGA designs, you'll want to talk to them from the ARM core. Here are some of the ways to do so. AHB <-> wishbone bridge The easiest way to talk to the FPGA is through the AHB<->wishbone bus, which directly maps into the ARM memory space. Block M4 base address Size Fabric (FPGA) 0x4002_0000 128KB Transactions must be intiated by the ARM. For bulk data transfer, consider the Packet FIFO interface. SDMA TODO Packet FIFO There are 4 fifo blocks: Block M4 base address Size RAMFIFO0 (FPGA) 0x4001_8000 4KB RAMFIFO1 (FPGA) 0x4001_9000 4KB RAMFIFO2 (FPGA) 0x4001_A000 4KB RAMFIFO3 (FPGA) 0x4001_B000 4KB TODO Interrupts There are 4 interrupt sources from the FPGA to the ARM. Intr Num NVIC Intr Address Exception Priority Comments 20 4 0x50 Fabric Message 0-7 (programmable) SoC WIC interrupts FB_0_INTR, FB_1_INTR, FB_2_INTR, FB_3_INTR Other peripherals (I2C, I2S, PDM, FFE, Sensor Manager) The datasheet and technical reference talk about some other useful peripherals, such as I2C, I2S, and PDM. Unfortunately, these peripherals seem to be attached to the Sensor Manager, and thus not directly accessable to the ARM part. It's unclear if the Sensor Manager is present in the version of the SoC that we have. The Flex Fusion Engine (FFE) is also mentioned, but is likely not enabled in the part variant that we have without some trickery. Fortunately, this is the kind of task that the FPGA is perfect for. For instance, if you want an I2C bus, or ten, you can design them using Verilog, then use them directly from the ARM core. You're free to make the best possbile peripherals!","title":"Pinout and Peripherals"},{"location":"pinout/#pinout-and-peripherals","text":"","title":"Pinout and Peripherals"},{"location":"pinout/#pinout","text":"Compared to a normal microcontroller, the pins on the QL-EOS-S3 SoC are a little goofy. Similar to a normal microcontroller, it has some hardware GPIO pins that are attached to the ARM core, along with standard peripherals such as UART, and SPI busses, along with an analog port. Unlike a normal microcontroller, however, most of the pins are not connected to the ARM core at all! Instead, they are all connected to the FPGA core, and can be used by writing your own peripherals in Verilog. Here is a map of all of the fixed pins on the board: All of the pins on the right and left sides of the boards can be used freely. Note that the two JTAG pins (IO_44 and IO_45 on RevB) have on-board pullup resistors to the 3.3V line. The pins in the center section are also possible to use use, however they affect how the SoC boots.","title":"Pinout"},{"location":"pinout/#use-with-caution-spi-pins","text":"The SPI pins (CLK, MOSI, MISO, and SS1) are attached to the on-board SPI flash. The CLK, MOSI, and MISO pins can be safely shared with other SPI devices, as long as they do not interfere with the boot process.","title":"Use with caution: SPI pins"},{"location":"pinout/#use-with-caution-bootstrap-pins","text":"IO_8, IO_9, IO_19, and IO_20 are avaiable as general-purpose IO, however they have 10k pull-down resistors connected to them, and their values have to be logic low at boot time for the microcontroller to turn on correctly.","title":"Use with caution: Bootstrap pins"},{"location":"pinout/#hardware-gpio","text":"The arm core is able to control 8 of the pins (marked GPIO0..7 in the pinout diagram). Here are the steps to use them:","title":"Hardware GPIO"},{"location":"pinout/#step-1-check-that-the-gpio-is-assigned-to-the-correct-pin","text":"Each GPIO can be connected to one of two hardware pins. The pin selection is stored in IOMUX_IO_REG_SEL, at 0x40004D60. Here is a table of the available GPIO pin mappings, and the proper one for the breakout board: GPIO Default pin Alternate pin Breakout board pin Notes 0 IO_6 IO_24 IO_6 1 IO_9 IO_26 IO_9 Bootstrap pin 2 IO_11 IO_28 IO_28 Breakout board uses alternate pin 3 IO_14 IO_30 IO_14 4 IO_18 IO_31 IO_18 Connected to USER BUTTON 5 IO_21 IO_36 IO_21 6 IO_22 IO_38 IO_22 Connected to STATUS LED 7 IO_23 IO_45 IO_23 Only GPIO2 needs to be assigned to the alternate pin, so the following can be used to fully configure the GPIO pin assignments: machine.mem32[0x40004D60] = (1<<2)","title":"Step 1: Check that the GPIO is assigned to the correct pin"},{"location":"pinout/#step-2-configure-the-pin-for-gpio-mode","text":"Now that we know the pin that the GPIO is assigned to, the next step is to configure it for GPIO mode, as either an input or output. To do this, write to the IOMUX_PADxx_CTRL register associated with the pad. The address is: 0x40004C00 + 4*(pad number) Example: Configure pin IO_18 as a GPIO input with pull-up enabled: machine.mem32[0x40004C00 + (18*4)] = (0x3<<0) | (0x0<<3) | (1<<8) | (1<<5) | (1<<11) | (0x1<<6) Example: Configure pin IO_22 as a GPIO output with 4mA drive strength: machine.mem32[0x40004C00 + (22*4)] = (0x3<<0) | (0x0<<3) | (1<<8)","title":"Step 2: Configure the pin for GPIO mode"},{"location":"pinout/#step-3-read-or-write-to-the-gpio","text":"To read from a gpio, use the register MISC_IO_INPUT at 0x40005100. For instance, to read the value of GPIO4 (user button): print((machine.mem32[0x40005100] >> 4) & 0x1) To write a GPIO value, us the register MISC_IO_OUTPUT at 0x40005104. For instance, to set GPIO6 (status led) high: machine.mem32[0x40005104] |= (1 << 6)","title":"Step 3: Read (or write) to the GPIO"},{"location":"pinout/#interrupts","text":"Each GPIO pin can be used as a level or edge sensitive interrupt. All GPIO pins share a single interrupt vector. TODO: Example for using interrupts","title":"Interrupts"},{"location":"pinout/#example-gpio-library","text":"Here is a barebones GPIO library, written in Micropython: class GPIO: IOMUX_BASE = 0x40004C00 IOMUX_IO_REG_SEL = 0x40004D60 MISC_IO_INPUT = 0x40005100 MISC_IO_OUTPUT = 0x40005104 def __init__(self): # Configure GPIO pin selects for breakout board # Note: Only GPIO2 uses alternate pin setting machine.mem32[self.IOMUX_IO_REG_SEL] = (1<<2) def write(self, gpio, val): if val == 0: # Low machine.mem32[self.MISC_IO_OUTPUT] &= ~(1 << gpio) else: # High machine.mem32[self.MISC_IO_OUTPUT] |= (1 << gpio) def read(self, gpio): return ((machine.mem32[self.MISC_IO_INPUT] >> gpio) & 0x01) def pinmode(self, gpio, mode): pads = (6,9,11,14,18,21,22,23) if mode == 'input': machine.mem32[self.IOMUX_BASE + pads[gpio]*4] = (0x3<<0) | (0x0<<3) | (1<<8) | (1<<5) | (1<<11) elif mode == 'input_pullup': machine.mem32[self.IOMUX_BASE + pads[gpio]*4] = (0x3<<0) | (0x0<<3) | (1<<8) | (1<<5) | (1<<11) | (0x1<<6) elif mode == 'output': machine.mem32[self.IOMUX_BASE + pads[gpio]*4] = (0x3<<0) | (0x0<<3) | (1<<8) And to use it: gpio=GPIO() gpio.pinmode(6,'output') gpio.write(6,1) # turn on LED gpio.pinmode(4,'input_pullup') gpio.read(4) # read button input","title":"Example GPIO library"},{"location":"pinout/#uart","text":"TODO","title":"UART"},{"location":"pinout/#spi-master","text":"SPI Master 1 is connected to the ARM, and available for use. Unfortunately, the technical reference manual is very light on the details, and the SDK drivers are buggy and poorly documented. It appears to be an instantion of a Synopsys DesignWire IP 'DW_apb_ssi'. Because this a commonly used IP block, there are some references to similar hardware: Linux driver TODO","title":"SPI Master"},{"location":"pinout/#analog-to-digital-controller","text":"TODO","title":"Analog to digital controller"},{"location":"pinout/#fpga","text":"The FPGA is the swiss army knife of peripherals","title":"FPGA"},{"location":"pinout/#clocks","text":"There are 3 input clocks from the ARM to the FPGA: Clock Name Max frequency Notes C16 Sys_Clk0 ? General purpose C21 Sys_Clk1 ? General purpose C02 Sys_Pclk ? SPI master APB bus clock (?) Sys_Clk0 and Sys_Clk1 are 'general purpose' clocks. Both are fed from dedicated clocks, so configuring them should not intefere with any other ARM peripherals. They can be driven by either the high or low speed system clocks, with a divisor from 0-512. The technical reference manual specifies a default maximum speed of 10MHz, however speeds up to the system clock (72MHz) appear to function well. Sys_Pclk is fed from C02, which is shared with some other ARM peripherals. It is also available for use, but reconfiguring it might cause problems. There are 2 output clocks from the FPGA to the ARM: Clock Name Max frequency Usage C40 WB_CLK 10 Mhz Fabric to Wishbone clock C41 Sys_Pkfb_Clk 10 MHz Fabric to PKFB (packet fifo) clock Both of these clocks are special purpose, and should be configured if you are planning to use their associated peripherals.","title":"Clocks"},{"location":"pinout/#io-pads","text":"The FPGA can control all of the IO pads, including a direction function. However, the pads must first be configured by the ARM processor, for both driving source and I/O control functions. Some of the pads are special clock inputs (TODO: which ones?)","title":"IO pads"},{"location":"pinout/#spi-master_1","text":"The FPGA is supposed to be able to interface with the SPI master, for some reason. It's not clear how to do this, or what the intended use case is.","title":"SPI Master"},{"location":"pinout/#communicating-with-the-fpga","text":"To get the best use out of your FPGA designs, you'll want to talk to them from the ARM core. Here are some of the ways to do so.","title":"Communicating with the FPGA"},{"location":"pinout/#ahb-wishbone-bridge","text":"The easiest way to talk to the FPGA is through the AHB<->wishbone bus, which directly maps into the ARM memory space. Block M4 base address Size Fabric (FPGA) 0x4002_0000 128KB Transactions must be intiated by the ARM. For bulk data transfer, consider the Packet FIFO interface.","title":"AHB &lt;-&gt; wishbone bridge"},{"location":"pinout/#sdma","text":"TODO","title":"SDMA"},{"location":"pinout/#packet-fifo","text":"There are 4 fifo blocks: Block M4 base address Size RAMFIFO0 (FPGA) 0x4001_8000 4KB RAMFIFO1 (FPGA) 0x4001_9000 4KB RAMFIFO2 (FPGA) 0x4001_A000 4KB RAMFIFO3 (FPGA) 0x4001_B000 4KB TODO","title":"Packet FIFO"},{"location":"pinout/#interrupts_1","text":"There are 4 interrupt sources from the FPGA to the ARM. Intr Num NVIC Intr Address Exception Priority Comments 20 4 0x50 Fabric Message 0-7 (programmable) SoC WIC interrupts FB_0_INTR, FB_1_INTR, FB_2_INTR, FB_3_INTR","title":"Interrupts"},{"location":"pinout/#other-peripherals-i2c-i2s-pdm-ffe-sensor-manager","text":"The datasheet and technical reference talk about some other useful peripherals, such as I2C, I2S, and PDM. Unfortunately, these peripherals seem to be attached to the Sensor Manager, and thus not directly accessable to the ARM part. It's unclear if the Sensor Manager is present in the version of the SoC that we have. The Flex Fusion Engine (FFE) is also mentioned, but is likely not enabled in the part variant that we have without some trickery. Fortunately, this is the kind of task that the FPGA is perfect for. For instance, if you want an I2C bus, or ten, you can design them using Verilog, then use them directly from the ARM core. You're free to make the best possbile peripherals!","title":"Other peripherals (I2C, I2S, PDM, FFE, Sensor Manager)"},{"location":"toolchain/","text":"Toolchain Setup Introduction This is based on Quickfeather getting started . There are instructions there for compiling from source. Prerequisites Some prerequisites for a Debian / Ubuntu environment: sudo apt install build-essential sudo apt remove modemmanager sudo usermod -a -G dialout $USER Note: If you just added your user to dialout, log out and then back in again to apply the new membership Let's attempt to contain everything in a single directory: export INSTALL_DIR=\"$HOME/ql-eos-s3\" mkdir $INSTALL_DIR cd $INSTALL_DIR ARM toolchain First up, get ARM GCC: wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/9-2020q2/gcc-arm-none-eabi-9-2020-q2-update-x86_64-linux.tar.bz2 tar xvjf gcc-arm-none-eabi-9-2020-q2-update-x86_64-linux.tar.bz2 -C $INSTALL_DIR export PATH=$INSTALL_DIR/gcc-arm-none-eabi-9-2020-q2-update/bin/:$PATH FPGA toolchain Then Symbiflow: wget 'https://github.com/QuickLogic-Corp/quicklogic-fpga-toolchain/releases/download/v1.3.0/Symbiflow_v1.3.0.gz.run' bash Symbiflow_v1.3.0.gz.run export PATH=\"$INSTALL_DIR/install/bin:$INSTALL_DIR/install/bin/python:$PATH\" source \"$INSTALL_DIR/conda/etc/profile.d/conda.sh\" conda activate And the TinyFPGA bootloader: git clone --recursive https://github.com/QuickLogic-Corp/TinyFPGA-Programmer-Application.git pip3 install pyserial pip3 install tinyfpgab Note: Make sure to activate conda in the previous step before using pip3 to install the python eggs SDK Now for the SDK and Blinkinlabs exmaples: git clone --recursive https://github.com/QuickLogic-Corp/qorc-sdk.git cd qorc-sdk git clone https://github.com/Blinkinlabs/bl_apps.git Default enviromnet To make the tools available in your default environment, add the following to your .bashrc: # ARM gcc toolchain export PATH=$HOME/ql-eos-s3/gcc-arm-none-eabi-9-2020-q2-update/bin/:$PATH # FPGA toolchain for ql-eos-s3 export INSTALL_DIR=\"$HOME/ql-eos-s3\" export PATH=\"$HOME/ql-eos-s3/install/bin:$HOME/ql-eos-s3/install/bin/python:$PATH\" source \"$HOME/ql-eos-s3/conda/etc/profile.d/conda.sh\" conda activate","title":"Toolchain Setup"},{"location":"toolchain/#toolchain-setup","text":"","title":"Toolchain Setup"},{"location":"toolchain/#introduction","text":"This is based on Quickfeather getting started . There are instructions there for compiling from source.","title":"Introduction"},{"location":"toolchain/#prerequisites","text":"Some prerequisites for a Debian / Ubuntu environment: sudo apt install build-essential sudo apt remove modemmanager sudo usermod -a -G dialout $USER Note: If you just added your user to dialout, log out and then back in again to apply the new membership Let's attempt to contain everything in a single directory: export INSTALL_DIR=\"$HOME/ql-eos-s3\" mkdir $INSTALL_DIR cd $INSTALL_DIR","title":"Prerequisites"},{"location":"toolchain/#arm-toolchain","text":"First up, get ARM GCC: wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/9-2020q2/gcc-arm-none-eabi-9-2020-q2-update-x86_64-linux.tar.bz2 tar xvjf gcc-arm-none-eabi-9-2020-q2-update-x86_64-linux.tar.bz2 -C $INSTALL_DIR export PATH=$INSTALL_DIR/gcc-arm-none-eabi-9-2020-q2-update/bin/:$PATH","title":"ARM toolchain"},{"location":"toolchain/#fpga-toolchain","text":"Then Symbiflow: wget 'https://github.com/QuickLogic-Corp/quicklogic-fpga-toolchain/releases/download/v1.3.0/Symbiflow_v1.3.0.gz.run' bash Symbiflow_v1.3.0.gz.run export PATH=\"$INSTALL_DIR/install/bin:$INSTALL_DIR/install/bin/python:$PATH\" source \"$INSTALL_DIR/conda/etc/profile.d/conda.sh\" conda activate And the TinyFPGA bootloader: git clone --recursive https://github.com/QuickLogic-Corp/TinyFPGA-Programmer-Application.git pip3 install pyserial pip3 install tinyfpgab Note: Make sure to activate conda in the previous step before using pip3 to install the python eggs","title":"FPGA toolchain"},{"location":"toolchain/#sdk","text":"Now for the SDK and Blinkinlabs exmaples: git clone --recursive https://github.com/QuickLogic-Corp/qorc-sdk.git cd qorc-sdk git clone https://github.com/Blinkinlabs/bl_apps.git","title":"SDK"},{"location":"toolchain/#default-enviromnet","text":"To make the tools available in your default environment, add the following to your .bashrc: # ARM gcc toolchain export PATH=$HOME/ql-eos-s3/gcc-arm-none-eabi-9-2020-q2-update/bin/:$PATH # FPGA toolchain for ql-eos-s3 export INSTALL_DIR=\"$HOME/ql-eos-s3\" export PATH=\"$HOME/ql-eos-s3/install/bin:$HOME/ql-eos-s3/install/bin/python:$PATH\" source \"$HOME/ql-eos-s3/conda/etc/profile.d/conda.sh\" conda activate","title":"Default enviromnet"}]}