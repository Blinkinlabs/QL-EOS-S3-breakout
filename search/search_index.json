{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"QL-EOS-S3-breakout A breadboard-friendly, low part count breakout board for the QuickLogic EOS-S3 ARM/FPGA IC. The goals of this project are: Low-cost, minimum viable ARM+FPGA design that is breadboard compatable Footprint, power, UART pin compatibility with Teensy 3.2. All pins on Bank A placed in a group, because they can have their IO voltage set with a reference Bootstrap, SPI flash, and reset pins placed in non-breadboardable location to avoid inadvertant interference with application circuit Pins with multiple IO functions preferred over FPGA only pins Pins in understandable (ascending) order by FPGA IO number, when possible See the release PDF for the schematic.","title":"QL-EOS-S3-breakout"},{"location":"#ql-eos-s3-breakout","text":"A breadboard-friendly, low part count breakout board for the QuickLogic EOS-S3 ARM/FPGA IC. The goals of this project are: Low-cost, minimum viable ARM+FPGA design that is breadboard compatable Footprint, power, UART pin compatibility with Teensy 3.2. All pins on Bank A placed in a group, because they can have their IO voltage set with a reference Bootstrap, SPI flash, and reset pins placed in non-breadboardable location to avoid inadvertant interference with application circuit Pins with multiple IO functions preferred over FPGA only pins Pins in understandable (ascending) order by FPGA IO number, when possible See the release PDF for the schematic.","title":"QL-EOS-S3-breakout"},{"location":"advanced/","text":"Advanced topics Reprogramming the SPI flash Introduction The EOS-S3 SoC does not have internal nonvolatile memory, so it boots from an external SPI flash. The breakout board has a bootloader pre-installed in the flash memory, which can be used to program the device using it's USB port. However, if the bootloader becomes corrupted for whatever reason, it can be useful to restore the whole SPI flash. To do this, you'll need a Teensy with the spiflash firmware loaded. First, some technical details. This is the flash memory layout that the quickfeather bootloader is expecting: Item Status Start Size End Start Size End bootloader Used 0x0000_0000 0x0001_0000 0x0000_FFFF 0 65,536 65,536 bootfpga CRC Used 0x0001_0000 8 0x0001_0007 65,536 8 65,544 appfpga CRC Future 0x0001_1000 8 0x0001_1007 69,632 8 69,640 appffe CRC Future 0x0001_2000 8 0x0001_2007 73,728 8 73,736 M4app CRC Used 0x0001_3000 8 0x0001_3007 77,824 8 77,832 bootloader CRC Used 0x0001_4000 8 0x0001_4007 81,920 8 81,928 bootfpga Used 0x0002_0000 0x0002_0000 0x0003_FFFF 131,072 131,072 262,144 appfpga Future 0x0004_0000 0x0002_0000 0x0005_FFFF 262,144 131,072 393,216 appffe Future 0x0006_0000 0x0002_0000 0x0007_FFFF 393,216 131,072 524,288 M4app Used 0x0008_0000 0x0006_E000 0x000E_DFFF 524,288 450,560 974,848 The hardware in the SoC only cares about the first section, which contains the bootloader. When it comes out of reset, configuration logic in the SoC reads 32 bits of data from the SPI flash location 0x120, which contains a device ID, the size of the bootloader image, and the desired SPI clock setting. If these are valid, the configuration logic then copies the bootloader into the device SRAM, and then starts the ARM processor. Once it starts, the bootloader displays a prompt on the UART pins, then waits 5 seconds. If the user button is pressed during these 5 seconds, then it loads the bootfpga image into the FPGA, which allows the user to reprogram the device using the TinyFPGA programmer. If the button is not pressed within 5 seconds, the bootloader attempts to load the user program from the SPI flash into SRAM. It then verifies that the CRC makes (TODO: Does it actually do this?), and if it does, reconfigures the ARM to point to that code, to enter the user program. The TLDR here is that if we want to write a raw image to the flash, we'll need at least the bootloader, bootloader CRC, bootfpga, andd bootfpga CRC sections to be present. For extra points, we can also preinstall a user app by filling the M4app and M4app CRC sections. Step 1: Build the bootloader First, let's build the bootloader: cd ~/ql-eos-s3/qorc-sdk/bl_apps/bl_bootloader/GCC_Project make TODO: what sets up the 0x120 offset in the bootloader binary? Step 2: Make a flash image A tool to build a suitable image is included in the bl apps . Using it with the default options will grab the bootloader binary image that we just compiled above, as well as a (for now) precompiled appfpga image: cd ~/ql-eos-s3/qorc-sdk/bl_apps/tools python3 build_flash_image.py added section:bootloader at:0x00000000 size:38228 crc:0x555d0a3e added section:bootfpga at:0x00020000 size:75960 crc:0x82fc1983 Wrote 0xee000 bytes to image.bin This should create a file called 'image.bin', which we can then load on the SPI flash chip, starting at offset 0. Step 3: Flash it Connect the Teensy to the dev board like so. Be sure to short the 'RST' pin on the board to 'GND', to prevent the SoC from booting: TODO: text version of the pin table Next, connect both the Teensy and the board to your computer using USB. Use your favorite serial terminal to connect to the Teensy. Issue the 'i' command to check if the SPI flash can be identified: i (device ID should be returned) Now, tell the Teensy that we want to write EE000 bytes to the SPI flash, starting at offset 0. If the flash image was a different length, use that instead: u0 EE0000 G 00000000 EE0000 Note: The 'u' will not be echoed to the terminal Exit the serial terminal, and then use the PV command to write the image: pv image.bin > /dev/ttyACM0 Now, detach the Teensy, then remove the jumper between RST and GND to boot flash image. Set the IO pins in Bank A to a different reference voltage Introduction If you need to interface with a device that uses a different logic voltage than 3.3V, it is possible to set the reference voltage for the pins on Bank A. Step 1: Cut the VCCIOA trace on the back of the board On the back side of the board, cut the short copper trace in the middle of the 'VCCIOA' pad. This will disconnect the VCCIOA power line from the on-board 3.3V regulator: Step 2: Provide a 1.71 - 3.6V reference on the VCCA pin Once the trace has been cut, you'll need to connect an external voltage to the header pin marked 'VCCA'. Then, all of the pins on the right-hand side of the board will be referenced to the external supply: Note: The datasheet specifies a range of 1.71-3.6V for safe operation Attach a JTAG debugger TODO Using JTAG with the RevB board reuqires pulling up both IO_8 and IO_9, and supplying a clock to FCLK. Additionally, the 10k pullups on SWD and SCK may not be present, and would need to be added externally. A future revision will use an alternate JTAG pin mapping, to allow it to be used with the on-board oscillator.","title":"Advanced Topics"},{"location":"advanced/#advanced-topics","text":"","title":"Advanced topics"},{"location":"advanced/#reprogramming-the-spi-flash","text":"","title":"Reprogramming the SPI flash"},{"location":"advanced/#introduction","text":"The EOS-S3 SoC does not have internal nonvolatile memory, so it boots from an external SPI flash. The breakout board has a bootloader pre-installed in the flash memory, which can be used to program the device using it's USB port. However, if the bootloader becomes corrupted for whatever reason, it can be useful to restore the whole SPI flash. To do this, you'll need a Teensy with the spiflash firmware loaded. First, some technical details. This is the flash memory layout that the quickfeather bootloader is expecting: Item Status Start Size End Start Size End bootloader Used 0x0000_0000 0x0001_0000 0x0000_FFFF 0 65,536 65,536 bootfpga CRC Used 0x0001_0000 8 0x0001_0007 65,536 8 65,544 appfpga CRC Future 0x0001_1000 8 0x0001_1007 69,632 8 69,640 appffe CRC Future 0x0001_2000 8 0x0001_2007 73,728 8 73,736 M4app CRC Used 0x0001_3000 8 0x0001_3007 77,824 8 77,832 bootloader CRC Used 0x0001_4000 8 0x0001_4007 81,920 8 81,928 bootfpga Used 0x0002_0000 0x0002_0000 0x0003_FFFF 131,072 131,072 262,144 appfpga Future 0x0004_0000 0x0002_0000 0x0005_FFFF 262,144 131,072 393,216 appffe Future 0x0006_0000 0x0002_0000 0x0007_FFFF 393,216 131,072 524,288 M4app Used 0x0008_0000 0x0006_E000 0x000E_DFFF 524,288 450,560 974,848 The hardware in the SoC only cares about the first section, which contains the bootloader. When it comes out of reset, configuration logic in the SoC reads 32 bits of data from the SPI flash location 0x120, which contains a device ID, the size of the bootloader image, and the desired SPI clock setting. If these are valid, the configuration logic then copies the bootloader into the device SRAM, and then starts the ARM processor. Once it starts, the bootloader displays a prompt on the UART pins, then waits 5 seconds. If the user button is pressed during these 5 seconds, then it loads the bootfpga image into the FPGA, which allows the user to reprogram the device using the TinyFPGA programmer. If the button is not pressed within 5 seconds, the bootloader attempts to load the user program from the SPI flash into SRAM. It then verifies that the CRC makes (TODO: Does it actually do this?), and if it does, reconfigures the ARM to point to that code, to enter the user program. The TLDR here is that if we want to write a raw image to the flash, we'll need at least the bootloader, bootloader CRC, bootfpga, andd bootfpga CRC sections to be present. For extra points, we can also preinstall a user app by filling the M4app and M4app CRC sections.","title":"Introduction"},{"location":"advanced/#step-1-build-the-bootloader","text":"First, let's build the bootloader: cd ~/ql-eos-s3/qorc-sdk/bl_apps/bl_bootloader/GCC_Project make TODO: what sets up the 0x120 offset in the bootloader binary?","title":"Step 1: Build the bootloader"},{"location":"advanced/#step-2-make-a-flash-image","text":"A tool to build a suitable image is included in the bl apps . Using it with the default options will grab the bootloader binary image that we just compiled above, as well as a (for now) precompiled appfpga image: cd ~/ql-eos-s3/qorc-sdk/bl_apps/tools python3 build_flash_image.py added section:bootloader at:0x00000000 size:38228 crc:0x555d0a3e added section:bootfpga at:0x00020000 size:75960 crc:0x82fc1983 Wrote 0xee000 bytes to image.bin This should create a file called 'image.bin', which we can then load on the SPI flash chip, starting at offset 0.","title":"Step 2: Make a flash image"},{"location":"advanced/#step-3-flash-it","text":"Connect the Teensy to the dev board like so. Be sure to short the 'RST' pin on the board to 'GND', to prevent the SoC from booting: TODO: text version of the pin table Next, connect both the Teensy and the board to your computer using USB. Use your favorite serial terminal to connect to the Teensy. Issue the 'i' command to check if the SPI flash can be identified: i (device ID should be returned) Now, tell the Teensy that we want to write EE000 bytes to the SPI flash, starting at offset 0. If the flash image was a different length, use that instead: u0 EE0000 G 00000000 EE0000 Note: The 'u' will not be echoed to the terminal Exit the serial terminal, and then use the PV command to write the image: pv image.bin > /dev/ttyACM0 Now, detach the Teensy, then remove the jumper between RST and GND to boot flash image.","title":"Step 3: Flash it"},{"location":"advanced/#set-the-io-pins-in-bank-a-to-a-different-reference-voltage","text":"","title":"Set the IO pins in Bank A to a different reference voltage"},{"location":"advanced/#introduction_1","text":"If you need to interface with a device that uses a different logic voltage than 3.3V, it is possible to set the reference voltage for the pins on Bank A.","title":"Introduction"},{"location":"advanced/#step-1-cut-the-vccioa-trace-on-the-back-of-the-board","text":"On the back side of the board, cut the short copper trace in the middle of the 'VCCIOA' pad. This will disconnect the VCCIOA power line from the on-board 3.3V regulator:","title":"Step 1: Cut the VCCIOA trace on the back of the board"},{"location":"advanced/#step-2-provide-a-171-36v-reference-on-the-vcca-pin","text":"Once the trace has been cut, you'll need to connect an external voltage to the header pin marked 'VCCA'. Then, all of the pins on the right-hand side of the board will be referenced to the external supply: Note: The datasheet specifies a range of 1.71-3.6V for safe operation","title":"Step 2: Provide a 1.71 - 3.6V reference on the VCCA pin"},{"location":"advanced/#attach-a-jtag-debugger","text":"TODO Using JTAG with the RevB board reuqires pulling up both IO_8 and IO_9, and supplying a clock to FCLK. Additionally, the 10k pullups on SWD and SCK may not be present, and would need to be added externally. A future revision will use an alternate JTAG pin mapping, to allow it to be used with the on-board oscillator.","title":"Attach a JTAG debugger"},{"location":"getting_started/","text":"Get Started Introduction The QL-EOS-S3 board is a unique, low-cost microcontroller with a built-in FPGA. What you need Hardware: QL-EOS-S3 breakout board USB-C cable 3.3V FTDI cable (or other USB-serial converter) (optional) Teensy 3.2 , for restoring the SPI flash. (optional) ARM SWD adapter, such as the Black magic probe Software: ARM GCC toolchain, to compile code for the Cortex M4 processor Symbiflow toolchain, for generating FPGA bitstreams The QORC Software Development Kit Blinkinlabs example projects Installation Step 1: Install the toolchain Follow the toolchain setup instructions Step 2: Build an example project Test a project that uses both the ARM and FPGA toolchains: cd ~/ql-eos-s3/qorc-sdk/bl_apps/bl_helloworldhw/GCC_Project make Step 3: Connect to the board Connect your board to your computer using a USB cable. Next, connect an FTDI cable: Open your favorite serial terminal, and connect to the FTDI serial port with 115200,8N1 setting. Press the reset button on the board (the one closest to the SPI flash chip). The device should send a prompt: ########################## Blinkinlabs QL-EOS-S3 Breakout Bootloader SW Version: qorc-sdk/qf-apps/qf_bootloader(v2) (GCC) Nov 11 2020 00:29:45 ########################## As soon as you see the prompt, press and hold the user button (the one furthest from the SPI flash chip). The device will then go into bootloader mode, and send a prompt: User button pressed: switch to download mode FPGA Programmed Presss Reset button after flashing .. If instead you see a message 'User button not pressed: proceeding to load application', just press reset, and try again. Step 4: Upload the example project And try uploading it to the board: python3 ~/ql-eos-s3/TinyFPGA-Programmer-Application/tinyfpga-programmer-gui.py --m4app output/bin/bl_helloworldhw.bin --reset CLI mode ports = ['/dev/ttyACM0 (QuickFeather)'] 1 Using port /dev/ttyACM0 (QuickFeather) Programming m4 application with bl_helloworldhw.bin Erasing designated flash pages Erase 64.0 KiB ( 0xd8 ) at 0x80000 Erase 32.0 KiB ( 0x52 ) at 0x90000 Erase 4.0 KiB ( 0x20 ) at 0x98000 Writing binary Write 102172 bytes [XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX] Verifying binary FastREAD 0x0B ( 102172 ) [XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX] Success: read_back == data Writing metadata Erasing designated flash pages Erase 4.0 KiB ( 0x20 ) at 0x13000 Writing metadata Write 8 bytes [X] ] Verifying metadata FastREAD 0x0B ( 8 ) [X] ] Success: read_back == data Reset the device boot sent On the serial terminal, the board should send progress updates: Addr: 0x00080000 Erase 64 KBytes() .. done Addr: 0x00090000 Erase 32 KBytes() .. done Addr: 0x00098000 Erase 4 KBytes() .. done Addr: 0x00013000 Erase 4 KBytes() .. done And once it's finished, it will automatically restart: ########################## Blinkinlabs QL-EOS-S3 Breakout Bootloader SW Version: qorc-sdk/qf-apps/qf_bootloader(v2) (GCC) Nov 11 2020 00:29:45 ########################## User button not pressed: proceeding to load application ########################## Quicklogic QuickFeather Standalone FPGA SW Version: qorc-sdk/qf_apps/qf_helloworldhw Nov 18 2020 18:01:17 ##########################","title":"Getting Started"},{"location":"getting_started/#get-started","text":"","title":"Get Started"},{"location":"getting_started/#introduction","text":"The QL-EOS-S3 board is a unique, low-cost microcontroller with a built-in FPGA.","title":"Introduction"},{"location":"getting_started/#what-you-need","text":"Hardware: QL-EOS-S3 breakout board USB-C cable 3.3V FTDI cable (or other USB-serial converter) (optional) Teensy 3.2 , for restoring the SPI flash. (optional) ARM SWD adapter, such as the Black magic probe Software: ARM GCC toolchain, to compile code for the Cortex M4 processor Symbiflow toolchain, for generating FPGA bitstreams The QORC Software Development Kit Blinkinlabs example projects","title":"What you need"},{"location":"getting_started/#installation","text":"","title":"Installation"},{"location":"getting_started/#step-1-install-the-toolchain","text":"Follow the toolchain setup instructions","title":"Step 1: Install the toolchain"},{"location":"getting_started/#step-2-build-an-example-project","text":"Test a project that uses both the ARM and FPGA toolchains: cd ~/ql-eos-s3/qorc-sdk/bl_apps/bl_helloworldhw/GCC_Project make","title":"Step 2: Build an example project"},{"location":"getting_started/#step-3-connect-to-the-board","text":"Connect your board to your computer using a USB cable. Next, connect an FTDI cable: Open your favorite serial terminal, and connect to the FTDI serial port with 115200,8N1 setting. Press the reset button on the board (the one closest to the SPI flash chip). The device should send a prompt: ########################## Blinkinlabs QL-EOS-S3 Breakout Bootloader SW Version: qorc-sdk/qf-apps/qf_bootloader(v2) (GCC) Nov 11 2020 00:29:45 ########################## As soon as you see the prompt, press and hold the user button (the one furthest from the SPI flash chip). The device will then go into bootloader mode, and send a prompt: User button pressed: switch to download mode FPGA Programmed Presss Reset button after flashing .. If instead you see a message 'User button not pressed: proceeding to load application', just press reset, and try again.","title":"Step 3: Connect to the board"},{"location":"getting_started/#step-4-upload-the-example-project","text":"And try uploading it to the board: python3 ~/ql-eos-s3/TinyFPGA-Programmer-Application/tinyfpga-programmer-gui.py --m4app output/bin/bl_helloworldhw.bin --reset CLI mode ports = ['/dev/ttyACM0 (QuickFeather)'] 1 Using port /dev/ttyACM0 (QuickFeather) Programming m4 application with bl_helloworldhw.bin Erasing designated flash pages Erase 64.0 KiB ( 0xd8 ) at 0x80000 Erase 32.0 KiB ( 0x52 ) at 0x90000 Erase 4.0 KiB ( 0x20 ) at 0x98000 Writing binary Write 102172 bytes [XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX] Verifying binary FastREAD 0x0B ( 102172 ) [XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX] Success: read_back == data Writing metadata Erasing designated flash pages Erase 4.0 KiB ( 0x20 ) at 0x13000 Writing metadata Write 8 bytes [X] ] Verifying metadata FastREAD 0x0B ( 8 ) [X] ] Success: read_back == data Reset the device boot sent On the serial terminal, the board should send progress updates: Addr: 0x00080000 Erase 64 KBytes() .. done Addr: 0x00090000 Erase 32 KBytes() .. done Addr: 0x00098000 Erase 4 KBytes() .. done Addr: 0x00013000 Erase 4 KBytes() .. done And once it's finished, it will automatically restart: ########################## Blinkinlabs QL-EOS-S3 Breakout Bootloader SW Version: qorc-sdk/qf-apps/qf_bootloader(v2) (GCC) Nov 11 2020 00:29:45 ########################## User button not pressed: proceeding to load application ########################## Quicklogic QuickFeather Standalone FPGA SW Version: qorc-sdk/qf_apps/qf_helloworldhw Nov 18 2020 18:01:17 ##########################","title":"Step 4: Upload the example project"},{"location":"pinout/","text":"Pinout Compared to a normal microcontroller, the pins on the QL-EOS-S3 SoC are a little goofy. Similar to a normal microcontroller, it has some hardware GPIO pins that are attached to the ARM core, along with standard peripherals such as UART, I2C, and SPI busses, along with an analog port. Unlike a normal microcontroller, however, most of the pins are not connected to the ARM core at all! Instead, they are all connected to the FPGA core, and can be used by writing your own peripherals in Verilog. Here is a map of all of the fixed pins on the board: Note: In the RevC board, some of the pins are shifted around, and ADC1 is replaced by IO_15 TODO: Table of available pins with alternate functions listed","title":"Pinout"},{"location":"pinout/#pinout","text":"Compared to a normal microcontroller, the pins on the QL-EOS-S3 SoC are a little goofy. Similar to a normal microcontroller, it has some hardware GPIO pins that are attached to the ARM core, along with standard peripherals such as UART, I2C, and SPI busses, along with an analog port. Unlike a normal microcontroller, however, most of the pins are not connected to the ARM core at all! Instead, they are all connected to the FPGA core, and can be used by writing your own peripherals in Verilog. Here is a map of all of the fixed pins on the board: Note: In the RevC board, some of the pins are shifted around, and ADC1 is replaced by IO_15 TODO: Table of available pins with alternate functions listed","title":"Pinout"},{"location":"toolchain/","text":"Toolchain Setup Introduction This is based on Quickfeather getting started . There are instructions there for compiling from source. Prerequisites Some prerequisites for a Debian / Ubuntu environment: sudo apt install build-essential sudo apt remove modemmanager sudo usermod -a -G dialout $USER Note: If you just added your user to dialout, log out and then back in again to apply the new membership Let's attempt to contain everything in a single directory: export INSTALL_DIR=\"$HOME/ql-eos-s3\" mkdir $INSTALL_DIR cd $INSTALL_DIR ARM toolchain First up, get ARM GCC: wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/9-2020q2/gcc-arm-none-eabi-9-2020-q2-update-x86_64-linux.tar.bz2 tar xvjf gcc-arm-none-eabi-9-2020-q2-update-x86_64-linux.tar.bz2 -C $INSTALL_DIR export PATH=$INSTALL_DIR/gcc-arm-none-eabi-9-2020-q2-update/bin/:$PATH FPGA toolchain Then Symbiflow: wget 'https://github.com/QuickLogic-Corp/quicklogic-fpga-toolchain/releases/download/v1.3.0/Symbiflow_v1.3.0.gz.run' bash Symbiflow_v1.3.0.gz.run export PATH=\"$INSTALL_DIR/install/bin:$INSTALL_DIR/install/bin/python:$PATH\" source \"$INSTALL_DIR/conda/etc/profile.d/conda.sh\" conda activate And the TinyFPGA bootloader: git clone --recursive https://github.com/QuickLogic-Corp/TinyFPGA-Programmer-Application.git pip3 install pyserial pip3 install tinyfpgab Note: Make sure to activate conda in the previous step before using pip3 to install the python eggs SDK Now for the SDK and Blinkinlabs exmaples: git clone --recursive https://github.com/QuickLogic-Corp/qorc-sdk.git cd qorc-sdk git clone https://github.com/Blinkinlabs/bl_apps.git Default enviromnet To make the tools available in your default environment, add the following to your .bashrc: # ARM gcc toolchain export PATH=$HOME/ql-eos-s3/gcc-arm-none-eabi-9-2020-q2-update/bin/:$PATH # FPGA toolchain for ql-eos-s3 export INSTALL_DIR=\"$HOME/ql-eos-s3\" export PATH=\"$HOME/ql-eos-s3/install/bin:$HOME/ql-eos-s3/install/bin/python:$PATH\" source \"$HOME/ql-eos-s3/conda/etc/profile.d/conda.sh\" conda activate","title":"Toolchain Setup"},{"location":"toolchain/#toolchain-setup","text":"","title":"Toolchain Setup"},{"location":"toolchain/#introduction","text":"This is based on Quickfeather getting started . There are instructions there for compiling from source.","title":"Introduction"},{"location":"toolchain/#prerequisites","text":"Some prerequisites for a Debian / Ubuntu environment: sudo apt install build-essential sudo apt remove modemmanager sudo usermod -a -G dialout $USER Note: If you just added your user to dialout, log out and then back in again to apply the new membership Let's attempt to contain everything in a single directory: export INSTALL_DIR=\"$HOME/ql-eos-s3\" mkdir $INSTALL_DIR cd $INSTALL_DIR","title":"Prerequisites"},{"location":"toolchain/#arm-toolchain","text":"First up, get ARM GCC: wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/9-2020q2/gcc-arm-none-eabi-9-2020-q2-update-x86_64-linux.tar.bz2 tar xvjf gcc-arm-none-eabi-9-2020-q2-update-x86_64-linux.tar.bz2 -C $INSTALL_DIR export PATH=$INSTALL_DIR/gcc-arm-none-eabi-9-2020-q2-update/bin/:$PATH","title":"ARM toolchain"},{"location":"toolchain/#fpga-toolchain","text":"Then Symbiflow: wget 'https://github.com/QuickLogic-Corp/quicklogic-fpga-toolchain/releases/download/v1.3.0/Symbiflow_v1.3.0.gz.run' bash Symbiflow_v1.3.0.gz.run export PATH=\"$INSTALL_DIR/install/bin:$INSTALL_DIR/install/bin/python:$PATH\" source \"$INSTALL_DIR/conda/etc/profile.d/conda.sh\" conda activate And the TinyFPGA bootloader: git clone --recursive https://github.com/QuickLogic-Corp/TinyFPGA-Programmer-Application.git pip3 install pyserial pip3 install tinyfpgab Note: Make sure to activate conda in the previous step before using pip3 to install the python eggs","title":"FPGA toolchain"},{"location":"toolchain/#sdk","text":"Now for the SDK and Blinkinlabs exmaples: git clone --recursive https://github.com/QuickLogic-Corp/qorc-sdk.git cd qorc-sdk git clone https://github.com/Blinkinlabs/bl_apps.git","title":"SDK"},{"location":"toolchain/#default-enviromnet","text":"To make the tools available in your default environment, add the following to your .bashrc: # ARM gcc toolchain export PATH=$HOME/ql-eos-s3/gcc-arm-none-eabi-9-2020-q2-update/bin/:$PATH # FPGA toolchain for ql-eos-s3 export INSTALL_DIR=\"$HOME/ql-eos-s3\" export PATH=\"$HOME/ql-eos-s3/install/bin:$HOME/ql-eos-s3/install/bin/python:$PATH\" source \"$HOME/ql-eos-s3/conda/etc/profile.d/conda.sh\" conda activate","title":"Default enviromnet"}]}