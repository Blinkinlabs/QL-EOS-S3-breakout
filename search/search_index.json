{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"QL-EOS-S3-breakout A breadboard-friendly, low part count breakout board for the QuickLogic EOS-S3 ARM/FPGA IC. The goals of this project are: Low-cost, minimum viable ARM+FPGA design that is breadboard compatable Footprint, power, UART pin compatibility with Teensy 3.2. All pins on Bank A placed in a group, because they can have their IO voltage set with a reference Bootstrap, SPI flash, and reset pins placed in non-breadboardable location to avoid inadvertant interference with application circuit Pins with multiple IO functions preferred over FPGA only pins Pins in understandable (ascending) order by FPGA IO number, when possible See the release PDF for the schematic.","title":"QL-EOS-S3-breakout"},{"location":"#ql-eos-s3-breakout","text":"A breadboard-friendly, low part count breakout board for the QuickLogic EOS-S3 ARM/FPGA IC. The goals of this project are: Low-cost, minimum viable ARM+FPGA design that is breadboard compatable Footprint, power, UART pin compatibility with Teensy 3.2. All pins on Bank A placed in a group, because they can have their IO voltage set with a reference Bootstrap, SPI flash, and reset pins placed in non-breadboardable location to avoid inadvertant interference with application circuit Pins with multiple IO functions preferred over FPGA only pins Pins in understandable (ascending) order by FPGA IO number, when possible See the release PDF for the schematic.","title":"QL-EOS-S3-breakout"},{"location":"advanced/","text":"Advanced topics Reprogramming the SPI flash Introduction The EOS-S3 SoC does not have internal nonvolatile memory, so it boots from an external SPI flash. The breakout board has a bootloader pre-installed in the flash memory, which can be used to program the device using it's USB port. However, if the bootloader becomes corrupted for whatever reason, it can be useful to restore the whole SPI flash. To do this, you'll need a Teensy with the spiflash firmware loaded. First, some technical details. This is the flash memory layout that the quickfeather bootloader is expecting: Item Status Start Size End Start Size End bootloader Used 0x0000_0000 0x0001_0000 0x0000_FFFF 0 65,536 65,536 bootfpga CRC Used 0x0001_0000 8 0x0001_0007 65,536 8 65,544 appfpga CRC Future 0x0001_1000 8 0x0001_1007 69,632 8 69,640 appffe CRC Future 0x0001_2000 8 0x0001_2007 73,728 8 73,736 M4app CRC Used 0x0001_3000 8 0x0001_3007 77,824 8 77,832 bootloader CRC Used 0x0001_4000 8 0x0001_4007 81,920 8 81,928 bootfpga Used 0x0002_0000 0x0002_0000 0x0003_FFFF 131,072 131,072 262,144 appfpga Future 0x0004_0000 0x0002_0000 0x0005_FFFF 262,144 131,072 393,216 appffe Future 0x0006_0000 0x0002_0000 0x0007_FFFF 393,216 131,072 524,288 M4app Used 0x0008_0000 0x0006_E000 0x000E_DFFF 524,288 450,560 974,848 The hardware in the SoC only cares about the first section, which contains the bootloader. When it comes out of reset, configuration logic in the SoC reads 32 bits of data from the SPI flash location 0x120, which contains a device ID, the size of the bootloader image, and the desired SPI clock setting. If these are valid, the configuration logic then copies the bootloader into the device SRAM, and then starts the ARM processor. Once it starts, the bootloader displays a prompt on the UART pins, then waits 5 seconds. If the user button is pressed during these 5 seconds, then it loads the bootfpga image into the FPGA, which allows the user to reprogram the device using the TinyFPGA programmer. If the button is not pressed within 5 seconds, the bootloader attempts to load the user program from the SPI flash into SRAM. It then verifies that the CRC makes (TODO: Does it actually do this?), and if it does, reconfigures the ARM to point to that code, to enter the user program. The TLDR here is that if we want to write a raw image to the flash, we'll need at least the bootloader, bootloader CRC, bootfpga, andd bootfpga CRC sections to be present. For extra points, we can also preinstall a user app by filling the M4app and M4app CRC sections. Build the bootloader First, let's build the bootloader: cd ~/ql-eos-s3/qorc-sdk/bl_apps/bl_bootloader/GCC_Project make TODO: what sets up the 0x120 offset in the bootloader binary? Make a flash image A tool to build a suitable image is included in the bl apps . Using it with the default options will grab the bootloader binary image that we just compiled above, as well as a (for now) precompiled appfpga image: cd ~/ql-eos-s3/qorc-sdk/bl_apps/tools python3 build_flash_image.py added section:bootloader at:0x00000000 size:38228 crc:0x555d0a3e added section:bootfpga at:0x00020000 size:75960 crc:0x82fc1983 Wrote 0xee000 bytes to image.bin This should create a file called 'image.bin', which we can then load on the SPI flash chip, starting at offset 0. Flash it Connect the Teensy to the dev board like so. Be sure to short the 'RST' pin on the board to 'GND', to prevent the SoC from booting: TODO: text version of the pin table Next, connect both the Teensy and the board to your computer using USB. Use your favorite serial terminal to connect to the Teensy. Issue the 'i' command to check if the SPI flash can be identified: i (device ID should be returned) Now, tell the Teensy that we want to write EE000 bytes to the SPI flash, starting at offset 0. If the flash image was a different length, use that instead: u0 EE0000 G 00000000 EE0000 Note: The 'u' will not be echoed to the terminal Exit the serial terminal, and then use the PV command to write the image: pv image.bin > /dev/ttyACM0 Now, detach the Teensy, then remove the jumper between RST and GND to boot flash image. Attach a JTAG debugger TODO Using JTAG with the RevB board reuqires pulling up both IO_8 and IO_9, and supplying a clock to FCLK. Additionally, the 10k pullups on SWD and SCK may not be present, and would need to be added externally. A future revision will use an alternate JTAG pin mapping, to allow it to be used with the on-board oscillator.","title":"Advanced Topics"},{"location":"advanced/#advanced-topics","text":"","title":"Advanced topics"},{"location":"advanced/#reprogramming-the-spi-flash","text":"","title":"Reprogramming the SPI flash"},{"location":"advanced/#introduction","text":"The EOS-S3 SoC does not have internal nonvolatile memory, so it boots from an external SPI flash. The breakout board has a bootloader pre-installed in the flash memory, which can be used to program the device using it's USB port. However, if the bootloader becomes corrupted for whatever reason, it can be useful to restore the whole SPI flash. To do this, you'll need a Teensy with the spiflash firmware loaded. First, some technical details. This is the flash memory layout that the quickfeather bootloader is expecting: Item Status Start Size End Start Size End bootloader Used 0x0000_0000 0x0001_0000 0x0000_FFFF 0 65,536 65,536 bootfpga CRC Used 0x0001_0000 8 0x0001_0007 65,536 8 65,544 appfpga CRC Future 0x0001_1000 8 0x0001_1007 69,632 8 69,640 appffe CRC Future 0x0001_2000 8 0x0001_2007 73,728 8 73,736 M4app CRC Used 0x0001_3000 8 0x0001_3007 77,824 8 77,832 bootloader CRC Used 0x0001_4000 8 0x0001_4007 81,920 8 81,928 bootfpga Used 0x0002_0000 0x0002_0000 0x0003_FFFF 131,072 131,072 262,144 appfpga Future 0x0004_0000 0x0002_0000 0x0005_FFFF 262,144 131,072 393,216 appffe Future 0x0006_0000 0x0002_0000 0x0007_FFFF 393,216 131,072 524,288 M4app Used 0x0008_0000 0x0006_E000 0x000E_DFFF 524,288 450,560 974,848 The hardware in the SoC only cares about the first section, which contains the bootloader. When it comes out of reset, configuration logic in the SoC reads 32 bits of data from the SPI flash location 0x120, which contains a device ID, the size of the bootloader image, and the desired SPI clock setting. If these are valid, the configuration logic then copies the bootloader into the device SRAM, and then starts the ARM processor. Once it starts, the bootloader displays a prompt on the UART pins, then waits 5 seconds. If the user button is pressed during these 5 seconds, then it loads the bootfpga image into the FPGA, which allows the user to reprogram the device using the TinyFPGA programmer. If the button is not pressed within 5 seconds, the bootloader attempts to load the user program from the SPI flash into SRAM. It then verifies that the CRC makes (TODO: Does it actually do this?), and if it does, reconfigures the ARM to point to that code, to enter the user program. The TLDR here is that if we want to write a raw image to the flash, we'll need at least the bootloader, bootloader CRC, bootfpga, andd bootfpga CRC sections to be present. For extra points, we can also preinstall a user app by filling the M4app and M4app CRC sections.","title":"Introduction"},{"location":"advanced/#build-the-bootloader","text":"First, let's build the bootloader: cd ~/ql-eos-s3/qorc-sdk/bl_apps/bl_bootloader/GCC_Project make TODO: what sets up the 0x120 offset in the bootloader binary?","title":"Build the bootloader"},{"location":"advanced/#make-a-flash-image","text":"A tool to build a suitable image is included in the bl apps . Using it with the default options will grab the bootloader binary image that we just compiled above, as well as a (for now) precompiled appfpga image: cd ~/ql-eos-s3/qorc-sdk/bl_apps/tools python3 build_flash_image.py added section:bootloader at:0x00000000 size:38228 crc:0x555d0a3e added section:bootfpga at:0x00020000 size:75960 crc:0x82fc1983 Wrote 0xee000 bytes to image.bin This should create a file called 'image.bin', which we can then load on the SPI flash chip, starting at offset 0.","title":"Make a flash image"},{"location":"advanced/#flash-it","text":"Connect the Teensy to the dev board like so. Be sure to short the 'RST' pin on the board to 'GND', to prevent the SoC from booting: TODO: text version of the pin table Next, connect both the Teensy and the board to your computer using USB. Use your favorite serial terminal to connect to the Teensy. Issue the 'i' command to check if the SPI flash can be identified: i (device ID should be returned) Now, tell the Teensy that we want to write EE000 bytes to the SPI flash, starting at offset 0. If the flash image was a different length, use that instead: u0 EE0000 G 00000000 EE0000 Note: The 'u' will not be echoed to the terminal Exit the serial terminal, and then use the PV command to write the image: pv image.bin > /dev/ttyACM0 Now, detach the Teensy, then remove the jumper between RST and GND to boot flash image.","title":"Flash it"},{"location":"advanced/#attach-a-jtag-debugger","text":"TODO Using JTAG with the RevB board reuqires pulling up both IO_8 and IO_9, and supplying a clock to FCLK. Additionally, the 10k pullups on SWD and SCK may not be present, and would need to be added externally. A future revision will use an alternate JTAG pin mapping, to allow it to be used with the on-board oscillator.","title":"Attach a JTAG debugger"},{"location":"getting_started/","text":"Get Started Introduction The QL-EOS-S3 board is a unique, low-cost microcontroller with a built-in FPGA. What you need Hardware: QL-EOS-S3 breakout board USB-C cable 3.3V FTDI cable (or other USB-serial converter) (optional) Teensy 3.2 , for restoring the SPI flash. (optional) ARM SWD adapter, such as the Black magic probe Software: ARM GCC toolchain, to compile code for the Cortex M4 processor Symbiflow toolchain, for generating FPGA bitstreams The QORC Software Development Kit Blinkinlabs example projects Installation Step 1: Install the toolchain Follow the toolchain setup instructions Step 2: Build an example project Test a project that uses both the ARM and FPGA toolchains: cd ~/qorc-sdk/bl_apps/bl_helloworldhw/GCC_Project make Step 3: Flash the project Connect your board to your computer using a USB cable, then connect an FTDI cable (technically optional): Open your favorite serial terminal, and connect to the FTDI serial port with 115200,8N1 setting. Press the reset button on the board (the one closest to the SPI flash chip). The device should send a prompt: and then immediately after press the user button (the other one). And try uploading it to the board: Note: First put your board in bootloader mode, by pressing the RESET button, followed by the USER button python3 $INSTALL_DIR/TinyFPGA-Programmer-Application/tinyfpga-programmer-gui.py --m4app output/bin/bl_helloworldhw.bin --reset","title":"Getting Started"},{"location":"getting_started/#get-started","text":"","title":"Get Started"},{"location":"getting_started/#introduction","text":"The QL-EOS-S3 board is a unique, low-cost microcontroller with a built-in FPGA.","title":"Introduction"},{"location":"getting_started/#what-you-need","text":"Hardware: QL-EOS-S3 breakout board USB-C cable 3.3V FTDI cable (or other USB-serial converter) (optional) Teensy 3.2 , for restoring the SPI flash. (optional) ARM SWD adapter, such as the Black magic probe Software: ARM GCC toolchain, to compile code for the Cortex M4 processor Symbiflow toolchain, for generating FPGA bitstreams The QORC Software Development Kit Blinkinlabs example projects","title":"What you need"},{"location":"getting_started/#installation","text":"","title":"Installation"},{"location":"getting_started/#step-1-install-the-toolchain","text":"Follow the toolchain setup instructions","title":"Step 1: Install the toolchain"},{"location":"getting_started/#step-2-build-an-example-project","text":"Test a project that uses both the ARM and FPGA toolchains: cd ~/qorc-sdk/bl_apps/bl_helloworldhw/GCC_Project make","title":"Step 2: Build an example project"},{"location":"getting_started/#step-3-flash-the-project","text":"Connect your board to your computer using a USB cable, then connect an FTDI cable (technically optional): Open your favorite serial terminal, and connect to the FTDI serial port with 115200,8N1 setting. Press the reset button on the board (the one closest to the SPI flash chip). The device should send a prompt: and then immediately after press the user button (the other one). And try uploading it to the board: Note: First put your board in bootloader mode, by pressing the RESET button, followed by the USER button python3 $INSTALL_DIR/TinyFPGA-Programmer-Application/tinyfpga-programmer-gui.py --m4app output/bin/bl_helloworldhw.bin --reset","title":"Step 3: Flash the project"},{"location":"toolchain/","text":"Toolchain Setup Introduction This is based on Quickfeather getting started . There are instructions there for compiling from source. Prerequisites Some prerequisites for a Debian / Ubuntu environment: sudo apt install build-essential sudo apt remove modemmanager sudo usermod -a -G dialout $USER Note: If you just added your user to dialout, log out and then back in again to apply the new membership Let's attempt to contain everything in a single directory: export INSTALL_DIR=\"$HOME/ql-eos-s3\" mkdir $INSTALL_DIR cd $INSTALL_DIR ARM toolchain First up, get ARM GCC: wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/9-2020q2/gcc-arm-none-eabi-9-2020-q2-update-x86_64-linux.tar.bz2 tar xvjf gcc-arm-none-eabi-9-2020-q2-update-x86_64-linux.tar.bz2 -C $INSTALL_DIR export PATH=$INSTALL_DIR/gcc-arm-none-eabi-9-2020-q2-update/bin/:$PATH FPGA toolchain Then Symbiflow: wget 'https://github.com/QuickLogic-Corp/quicklogic-fpga-toolchain/releases/download/v1.3.0/Symbiflow_v1.3.0.gz.run' bash Symbiflow_v1.3.0.gz.run export PATH=\"$INSTALL_DIR/install/bin:$INSTALL_DIR/install/bin/python:$PATH\" source \"$INSTALL_DIR/conda/etc/profile.d/conda.sh\" conda activate And the TinyFPGA bootloader: git clone --recursive https://github.com/QuickLogic-Corp/TinyFPGA-Programmer-Application.git pip3 install pyserial pip3 install tinyfpgab Note: Make sure to activate conda in the previous step before using pip3 to install the python eggs SDK Now for the SDK and Blinkinlabs exmaples: git clone --recursive https://github.com/QuickLogic-Corp/qorc-sdk.git cd qorc-sdk git clone https://github.com/Blinkinlabs/bl_apps.git Default enviromnet To make the tools available in your default environment, add the following to your .bashrc: # ARM gcc toolchain export PATH=$HOME/ql-eos-s3/gcc-arm-none-eabi-9-2020-q2-update/bin/:$PATH # FPGA toolchain for ql-eos-s3 export INSTALL_DIR=\"$HOME/ql-eos-s3\" export PATH=\"$HOME/ql-eos-s3/install/bin:$HOME/ql-eos-s3/install/bin/python:$PATH\" source \"$HOME/ql-eos-s3/conda/etc/profile.d/conda.sh\" conda activate","title":"Toolchain Setup"},{"location":"toolchain/#toolchain-setup","text":"","title":"Toolchain Setup"},{"location":"toolchain/#introduction","text":"This is based on Quickfeather getting started . There are instructions there for compiling from source.","title":"Introduction"},{"location":"toolchain/#prerequisites","text":"Some prerequisites for a Debian / Ubuntu environment: sudo apt install build-essential sudo apt remove modemmanager sudo usermod -a -G dialout $USER Note: If you just added your user to dialout, log out and then back in again to apply the new membership Let's attempt to contain everything in a single directory: export INSTALL_DIR=\"$HOME/ql-eos-s3\" mkdir $INSTALL_DIR cd $INSTALL_DIR","title":"Prerequisites"},{"location":"toolchain/#arm-toolchain","text":"First up, get ARM GCC: wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/9-2020q2/gcc-arm-none-eabi-9-2020-q2-update-x86_64-linux.tar.bz2 tar xvjf gcc-arm-none-eabi-9-2020-q2-update-x86_64-linux.tar.bz2 -C $INSTALL_DIR export PATH=$INSTALL_DIR/gcc-arm-none-eabi-9-2020-q2-update/bin/:$PATH","title":"ARM toolchain"},{"location":"toolchain/#fpga-toolchain","text":"Then Symbiflow: wget 'https://github.com/QuickLogic-Corp/quicklogic-fpga-toolchain/releases/download/v1.3.0/Symbiflow_v1.3.0.gz.run' bash Symbiflow_v1.3.0.gz.run export PATH=\"$INSTALL_DIR/install/bin:$INSTALL_DIR/install/bin/python:$PATH\" source \"$INSTALL_DIR/conda/etc/profile.d/conda.sh\" conda activate And the TinyFPGA bootloader: git clone --recursive https://github.com/QuickLogic-Corp/TinyFPGA-Programmer-Application.git pip3 install pyserial pip3 install tinyfpgab Note: Make sure to activate conda in the previous step before using pip3 to install the python eggs","title":"FPGA toolchain"},{"location":"toolchain/#sdk","text":"Now for the SDK and Blinkinlabs exmaples: git clone --recursive https://github.com/QuickLogic-Corp/qorc-sdk.git cd qorc-sdk git clone https://github.com/Blinkinlabs/bl_apps.git","title":"SDK"},{"location":"toolchain/#default-enviromnet","text":"To make the tools available in your default environment, add the following to your .bashrc: # ARM gcc toolchain export PATH=$HOME/ql-eos-s3/gcc-arm-none-eabi-9-2020-q2-update/bin/:$PATH # FPGA toolchain for ql-eos-s3 export INSTALL_DIR=\"$HOME/ql-eos-s3\" export PATH=\"$HOME/ql-eos-s3/install/bin:$HOME/ql-eos-s3/install/bin/python:$PATH\" source \"$HOME/ql-eos-s3/conda/etc/profile.d/conda.sh\" conda activate","title":"Default enviromnet"}]}